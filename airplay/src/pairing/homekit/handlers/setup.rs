use std::{borrow::Cow, ops::BitXor};

use bytes::Bytes;
use num_bigint::BigUint;
use rand::Rng;
use sha2::{Digest, Sha512};
use srp::{client::SrpClient, groups::G_3072, server::SrpServer, types::SrpGroup};

use crate::config::PinCode;

use super::super::dto::ErrorCode;

type SaltArray = [u8; 16];
type PrivKeyArray = [u8; 64];

pub enum State {
    Init {
        username: &'static str,
        password: Cow<'static, str>,
    },
    AuthStart {
        salt: SaltArray,
        privkey: PrivKeyArray,
        username: &'static str,
        verifier: Vec<u8>,
    },
    Transient {
        session_key: Bytes,
    },
    // TODO: non-transient with encryption of tcp channel
}

impl State {
    pub fn new(pin: Option<PinCode>) -> Self {
        const PAIR_SETUP_USERNAME: &str = "Pair-Setup";
        const PAIR_SETUP_DEFAULT_PASSWORD: &str = "3939";

        let username = PAIR_SETUP_USERNAME;
        let password = if let Some(pin) = pin {
            Cow::Owned(format!("{pin}"))
        } else {
            Cow::Borrowed(PAIR_SETUP_DEFAULT_PASSWORD)
        };

        Self::Init { username, password }
    }

    pub fn m1_m2(&mut self, mut random: impl Rng) -> Result<(Vec<u8>, Vec<u8>), ErrorCode> {
        let Self::Init { username, password } = &self else {
            return Err(ErrorCode::Busy);
        };

        let mut salt: SaltArray = [0u8; _];
        let mut privkey: PrivKeyArray = [0u8; _];
        random.fill(&mut salt);
        random.fill(&mut privkey);

        let srp_client = SrpClient::<Sha512>::new(&G_3072);
        let verifier = srp_client.compute_verifier(username.as_bytes(), password.as_bytes(), &salt);

        let srp_server = SrpServer::<Sha512>::new(&G_3072);
        let pubkey = srp_server.compute_public_ephemeral(&privkey, &verifier);

        *self = Self::AuthStart {
            salt,
            privkey,
            username,
            verifier,
        };

        Ok((pubkey, salt.to_vec()))
    }

    pub fn m3_m4(
        &mut self,
        client_pubkey: &[u8],
        client_proof: &[u8],
    ) -> Result<Vec<u8>, ErrorCode> {
        let Self::AuthStart {
            salt,
            privkey,
            username,
            verifier,
        } = self
        else {
            return Err(ErrorCode::Busy);
        };

        let srp_server = SrpServer::<Sha512>::new(&G_3072);

        let Ok(reply) = srp_server.process_reply(privkey, verifier, client_pubkey) else {
            return Err(ErrorCode::Authentication);
        };

        let key = {
            let mut d = Sha512::new();
            d.update(reply.key());
            d.finalize()
        };

        let server_pubkey = srp_server.compute_public_ephemeral(privkey, verifier);
        let Some(server_proof) = verify_client_proof::<Sha512>(
            &server_pubkey,
            client_pubkey,
            client_proof,
            username.as_bytes(),
            salt,
            &key,
            &G_3072,
        ) else {
            return Err(ErrorCode::Authentication);
        };

        let session_key = Bytes::from_owner(key.to_vec());
        *self = Self::Transient {
            session_key: session_key.clone(),
        };

        Ok(server_proof)
    }
}

fn verify_client_proof<D: Digest>(
    b_pub: &[u8],
    a_pub: &[u8],
    a_proof: &[u8],
    username: &[u8],
    salt: &[u8],
    key: &[u8],
    group: &SrpGroup,
) -> Option<Vec<u8>> {
    let mut dhn = D::new();
    dhn.update(group.n.to_bytes_be());
    let hn = BigUint::from_bytes_be(&dhn.finalize());

    let mut dhg = D::new();
    dhg.update(group.g.to_bytes_be());
    let hg = BigUint::from_bytes_be(&dhg.finalize());

    let hng = hn.bitxor(hg);

    let mut dhi = D::new();
    dhi.update(username);
    let hi = dhi.finalize();

    let mut d = D::new();
    // M = H(H(N) xor H(g), H(I), s, A, B, K)
    d.update(hng.to_bytes_be());
    d.update(&hi);
    d.update(salt);
    d.update(a_pub);
    d.update(b_pub);
    d.update(key);

    if a_proof == d.finalize().as_slice() {
        // H(A, M, K)
        let mut d = D::new();
        d.update(a_pub);
        d.update(a_proof);
        d.update(key);
        Some(d.finalize().as_slice().to_vec())
    } else {
        None
    }
}

#[cfg(test)]
#[allow(non_upper_case_globals)]
mod tests {
    use rand::RngCore;

    use super::*;

    const s: [u8; 16] = [
        182, 14, 130, 190, 42, 45, 109, 155, 242, 253, 216, 201, 155, 43, 162, 148,
    ];
    const v: &[u8] = &[
        55, 37, 252, 232, 231, 66, 221, 93, 148, 11, 87, 53, 247, 244, 238, 115, 178, 60, 252, 238,
        200, 76, 43, 159, 135, 61, 43, 63, 254, 108, 245, 92, 64, 41, 183, 229, 4, 10, 200, 54, 6,
        73, 243, 117, 170, 241, 121, 52, 63, 148, 39, 227, 223, 6, 244, 181, 32, 189, 90, 143, 138,
        55, 125, 15, 241, 33, 179, 153, 67, 72, 15, 245, 216, 37, 46, 47, 35, 84, 167, 56, 192, 49,
        79, 205, 249, 253, 63, 8, 134, 108, 95, 175, 72, 100, 245, 10, 83, 255, 244, 57, 96, 7, 63,
        18, 25, 37, 234, 120, 219, 211, 52, 111, 231, 191, 38, 232, 217, 231, 15, 247, 115, 232,
        113, 13, 37, 40, 178, 119, 147, 31, 163, 75, 79, 142, 34, 8, 197, 185, 228, 84, 235, 193,
        142, 62, 49, 184, 253, 167, 140, 212, 26, 57, 215, 211, 96, 130, 160, 3, 2, 31, 159, 235,
        253, 65, 179, 223, 217, 100, 228, 49, 210, 133, 136, 161, 222, 57, 119, 110, 37, 90, 165,
        227, 136, 107, 57, 94, 188, 32, 49, 14, 66, 125, 249, 28, 75, 186, 68, 223, 174, 13, 134,
        81, 232, 15, 79, 128, 171, 89, 218, 12, 98, 176, 66, 0, 236, 175, 161, 232, 157, 119, 53,
        249, 193, 37, 154, 25, 166, 218, 15, 95, 237, 175, 132, 251, 1, 255, 36, 168, 2, 48, 43,
        99, 100, 80, 126, 223, 205, 194, 212, 146, 221, 160, 115, 204, 55, 42, 90, 248, 220, 104,
        106, 5, 116, 68, 189, 123, 167, 208, 186, 211, 70, 212, 17, 31, 177, 8, 165, 53, 60, 108,
        220, 253, 176, 199, 80, 205, 145, 150, 67, 25, 182, 148, 53, 250, 166, 242, 166, 219, 141,
        119, 25, 109, 236, 246, 34, 193, 141, 7, 254, 17, 126, 139, 25, 124, 166, 61, 201, 171,
        185, 223, 252, 67, 191, 3, 225, 44, 180, 210, 180, 2, 70, 101, 176, 184, 175, 197, 11, 123,
        167, 78, 202, 219, 98, 93, 80, 13, 61, 53, 53, 106, 82, 167, 7, 58, 175, 206, 92, 143, 137,
        150, 19, 164, 160, 241, 23, 46, 153, 194, 77, 146, 107, 120, 133, 7, 117, 158, 59, 195,
        116, 13, 176, 213, 10, 121,
    ];
    const b: [u8; 64] = [
        191, 85, 237, 93, 149, 43, 112, 166, 154, 159, 214, 74, 28, 72, 248, 254, 140, 164, 163,
        175, 196, 197, 120, 2, 124, 22, 6, 11, 130, 171, 57, 77, 184, 107, 45, 193, 193, 234, 209,
        71, 157, 252, 170, 174, 180, 218, 150, 102, 49, 164, 55, 78, 79, 247, 110, 209, 21, 128,
        244, 67, 164, 199, 67, 222,
    ];
    const B: &[u8] = &[
        168, 110, 137, 254, 225, 245, 29, 126, 125, 182, 43, 133, 19, 20, 78, 193, 78, 184, 10, 47,
        69, 166, 142, 200, 198, 255, 49, 251, 234, 218, 22, 207, 163, 134, 233, 129, 105, 38, 111,
        233, 127, 186, 221, 203, 134, 110, 207, 147, 143, 221, 48, 237, 55, 193, 200, 12, 124, 74,
        14, 193, 251, 56, 5, 254, 37, 54, 251, 187, 224, 55, 151, 87, 21, 238, 227, 192, 152, 115,
        163, 18, 139, 16, 31, 99, 220, 242, 32, 130, 177, 216, 217, 226, 178, 233, 182, 172, 177,
        185, 235, 126, 12, 97, 42, 127, 126, 71, 99, 68, 10, 206, 126, 223, 19, 214, 161, 136, 194,
        159, 236, 0, 116, 78, 244, 189, 222, 201, 129, 242, 249, 85, 182, 19, 101, 10, 80, 33, 76,
        112, 19, 98, 178, 204, 120, 118, 135, 26, 175, 205, 212, 168, 135, 203, 74, 101, 133, 176,
        57, 218, 231, 79, 191, 254, 0, 216, 188, 107, 213, 99, 17, 183, 139, 34, 243, 231, 57, 82,
        137, 77, 154, 161, 232, 18, 73, 110, 30, 163, 230, 193, 36, 192, 38, 128, 8, 35, 90, 82,
        35, 124, 161, 41, 70, 168, 203, 98, 16, 214, 28, 140, 146, 181, 246, 202, 24, 34, 229, 56,
        182, 194, 101, 8, 223, 239, 240, 130, 73, 222, 146, 238, 224, 58, 191, 244, 24, 176, 183,
        160, 100, 207, 3, 30, 23, 183, 44, 159, 252, 158, 172, 180, 166, 161, 201, 209, 183, 141,
        88, 39, 190, 216, 213, 14, 169, 215, 6, 91, 166, 131, 125, 52, 246, 206, 71, 209, 74, 104,
        2, 205, 240, 150, 180, 139, 219, 107, 5, 74, 104, 42, 66, 193, 145, 236, 244, 77, 117, 160,
        48, 153, 45, 125, 193, 50, 205, 194, 64, 195, 223, 234, 109, 101, 179, 37, 150, 200, 24,
        183, 217, 76, 26, 70, 112, 118, 23, 134, 96, 103, 14, 106, 129, 162, 226, 239, 210, 94,
        123, 221, 249, 56, 86, 64, 111, 90, 224, 53, 92, 185, 187, 38, 88, 197, 118, 230, 48, 142,
        179, 8, 183, 205, 244, 139, 156, 48, 233, 55, 177, 65, 121, 125, 180, 206, 234, 100, 205,
        205, 215, 0, 248, 20, 212, 218, 129, 164, 141, 228, 90, 70,
    ];
    const A: &[u8] = &[
        66, 83, 212, 246, 87, 0, 80, 45, 236, 35, 245, 239, 166, 200, 90, 42, 16, 179, 28, 95, 227,
        65, 93, 178, 170, 173, 133, 192, 20, 133, 212, 250, 59, 48, 22, 16, 236, 203, 169, 137, 9,
        119, 162, 150, 35, 138, 129, 177, 86, 59, 13, 49, 106, 134, 156, 163, 124, 18, 156, 254,
        49, 8, 163, 249, 152, 223, 118, 214, 35, 190, 229, 176, 154, 7, 204, 179, 85, 78, 253, 190,
        2, 17, 109, 96, 79, 164, 118, 137, 227, 112, 38, 42, 164, 207, 165, 205, 255, 221, 247,
        168, 19, 137, 186, 13, 62, 217, 107, 56, 216, 194, 157, 167, 81, 255, 82, 123, 101, 207,
        72, 215, 210, 159, 183, 156, 17, 167, 46, 79, 16, 173, 125, 27, 42, 113, 175, 62, 35, 195,
        175, 239, 153, 223, 102, 192, 46, 238, 252, 228, 74, 207, 243, 32, 25, 217, 187, 249, 33,
        92, 19, 57, 225, 71, 160, 207, 178, 0, 6, 185, 116, 136, 35, 229, 251, 111, 133, 190, 165,
        94, 7, 65, 203, 148, 238, 102, 63, 215, 221, 199, 158, 124, 107, 69, 11, 89, 164, 248, 195,
        66, 144, 154, 186, 160, 228, 5, 178, 191, 32, 135, 92, 55, 134, 145, 24, 11, 63, 214, 61,
        98, 4, 189, 134, 65, 119, 173, 177, 237, 40, 61, 191, 24, 133, 108, 163, 242, 121, 229,
        213, 118, 174, 88, 194, 116, 14, 218, 13, 217, 16, 75, 1, 65, 80, 170, 165, 185, 100, 60,
        101, 58, 153, 133, 89, 242, 199, 203, 225, 86, 88, 85, 113, 112, 83, 192, 100, 95, 223, 78,
        176, 68, 161, 62, 134, 61, 51, 209, 25, 67, 55, 64, 174, 205, 27, 187, 38, 209, 225, 67,
        169, 36, 121, 43, 179, 50, 162, 57, 34, 101, 226, 221, 10, 149, 108, 3, 35, 218, 237, 250,
        20, 198, 123, 107, 157, 121, 97, 188, 208, 18, 136, 243, 230, 164, 157, 160, 57, 170, 94,
        125, 126, 153, 87, 41, 163, 233, 240, 37, 33, 214, 103, 18, 31, 25, 143, 223, 244, 39, 51,
        202, 117, 159, 76, 74, 76, 3, 45, 99, 18, 29, 9, 73, 122, 0, 70, 65, 229, 221, 99, 203, 22,
        169, 124, 26, 28, 227, 38, 176,
    ];
    const K: &[u8] = &[
        157, 15, 67, 105, 217, 231, 94, 131, 93, 166, 167, 201, 39, 91, 61, 114, 21, 18, 5, 55,
        250, 33, 215, 168, 242, 143, 135, 226, 70, 162, 76, 166, 4, 87, 107, 250, 222, 72, 53, 199,
        243, 73, 229, 111, 29, 32, 116, 236, 254, 183, 175, 128, 148, 167, 111, 141, 138, 81, 238,
        194, 134, 70, 156, 117,
    ];
    const M1: &[u8] = &[
        246, 111, 83, 159, 179, 26, 220, 113, 155, 160, 160, 147, 242, 191, 109, 154, 214, 41, 64,
        245, 10, 62, 10, 67, 193, 23, 170, 229, 25, 135, 90, 53, 213, 138, 218, 231, 122, 188, 71,
        160, 64, 197, 209, 95, 198, 57, 223, 183, 116, 251, 125, 29, 141, 223, 25, 235, 70, 51, 73,
        249, 234, 104, 252, 133,
    ];
    const M2: &[u8] = &[
        174, 254, 88, 248, 151, 155, 238, 151, 37, 251, 118, 35, 37, 126, 76, 208, 64, 70, 8, 94,
        141, 207, 164, 126, 159, 241, 224, 21, 218, 205, 57, 68, 235, 158, 91, 4, 223, 18, 207,
        139, 98, 55, 95, 93, 182, 201, 169, 182, 251, 193, 163, 246, 37, 157, 190, 166, 236, 22,
        164, 39, 232, 140, 178, 94,
    ];

    #[test]
    fn test_handshake() {
        struct TestRandom {
            count: usize,
        }

        impl RngCore for TestRandom {
            fn next_u32(&mut self) -> u32 {
                unimplemented!()
            }

            fn next_u64(&mut self) -> u64 {
                unimplemented!()
            }

            fn fill_bytes(&mut self, dst: &mut [u8]) {
                match self.count {
                    0 => dst.copy_from_slice(&s),
                    1 => dst.copy_from_slice(&b),
                    _ => unreachable!(),
                }
                self.count += 1;
            }
        }

        let mut state = State::new(None);

        let Ok((pubkey, salt)) = state.m1_m2(TestRandom { count: 0 }) else {
            panic!("m1m2");
        };
        assert_eq!(B, pubkey);
        assert_eq!(s, salt.as_slice());

        let State::AuthStart {
            salt,
            privkey,
            username,
            verifier,
        } = &state
        else {
            unreachable!()
        };

        assert_eq!(s, salt.as_slice());
        assert_eq!(b, privkey.as_slice());
        assert_eq!(&"Pair-Setup", username);
        assert_eq!(v, verifier);

        let Ok(server_proof) = state.m3_m4(A, M1) else {
            panic!("m3m4");
        };
        let State::Transient { session_key } = &state else {
            unreachable!()
        };

        assert_eq!(server_proof, M2);
        assert_eq!(session_key, K);
    }

    // Test from:
    // https://github.com/ewilken/hap-rs/blob/acf45bdb00e23c81b67b3d5116c113335dc83f16/src/transport/http/handler/pair_setup.rs#L415
    #[test]
    fn test_verify_client_proof() {
        let b_pub = [
            66, 254, 195, 54, 248, 36, 231, 56, 186, 118, 54, 42, 5, 66, 113, 73, 150, 54, 54, 156,
            16, 76, 252, 50, 206, 135, 204, 173, 159, 174, 68, 125, 23, 251, 75, 215, 136, 102,
            165, 73, 107, 249, 205, 158, 32, 192, 157, 134, 17, 70, 51, 225, 74, 3, 195, 74, 124,
            137, 26, 48, 245, 253, 212, 197, 29, 141, 12, 5, 36, 191, 77, 203, 137, 72, 27, 38,
            231, 136, 43, 60, 134, 137, 192, 134, 218, 13, 90, 232, 166, 245, 168, 29, 34, 91, 121,
            185, 82, 144, 146, 215, 6, 120, 204, 126, 217, 146, 135, 243, 55, 1, 99, 159, 192, 53,
            80, 103, 19, 87, 253, 193, 104, 98, 228, 167, 138, 214, 84, 135, 232, 225, 185, 158,
            114, 48, 228, 110, 137, 109, 32, 21, 227, 177, 18, 241, 240, 240, 125, 115, 135, 46,
            249, 172, 206, 170, 41, 76, 169, 163, 62, 77, 94, 51, 116, 69, 188, 218, 171, 90, 171,
            128, 163, 84, 233, 52, 134, 77, 70, 130, 207, 84, 55, 218, 155, 199, 67, 214, 10, 25,
            142, 134, 34, 65, 43, 52, 113, 92, 234, 213, 101, 32, 12, 34, 87, 31, 82, 132, 175,
            144, 116, 36, 47, 119, 221, 46, 103, 44, 80, 74, 201, 196, 249, 230, 127, 123, 80, 118,
            216, 163, 249, 186, 218, 184, 181, 144, 72, 187, 101, 164, 150, 209, 45, 247, 70, 184,
            92, 155, 146, 175, 162, 54, 95, 155, 174, 116, 38, 190, 166, 137, 133, 51, 253, 21,
            169, 129, 167, 61, 102, 49, 115, 24, 245, 130, 171, 6, 196, 177, 44, 49, 149, 39, 239,
            142, 253, 49, 123, 226, 140, 40, 43, 193, 131, 20, 30, 17, 57, 252, 1, 68, 55, 1, 227,
            226, 24, 73, 204, 237, 230, 2, 81, 203, 54, 204, 157, 174, 22, 134, 126, 132, 106, 66,
            115, 27, 189, 157, 131, 173, 205, 36, 140, 160, 183, 171, 62, 97, 7, 73, 93, 114, 199,
            50, 192, 22, 56, 132, 172, 61, 208, 84, 102, 85, 60, 216, 170, 249, 29, 66, 158, 48,
            221, 78, 166, 50, 20, 203, 99, 206, 6, 112, 163, 194, 43, 165, 176, 193, 62, 157, 184,
            57, 235, 221, 175, 46, 7, 152,
        ];
        let a_pub = [
            21, 187, 129, 247, 180, 115, 7, 3, 46, 219, 190, 0, 89, 8, 126, 225, 37, 159, 98, 137,
            226, 202, 13, 228, 31, 55, 17, 244, 180, 120, 159, 97, 141, 126, 131, 219, 227, 64, 81,
            24, 99, 206, 12, 218, 27, 95, 43, 216, 151, 228, 46, 89, 133, 153, 100, 55, 134, 206,
            65, 165, 244, 228, 121, 88, 78, 54, 19, 220, 48, 86, 150, 92, 21, 168, 219, 226, 214,
            254, 33, 26, 135, 134, 247, 49, 58, 114, 245, 76, 67, 182, 223, 191, 93, 1, 131, 58,
            76, 62, 49, 123, 11, 10, 164, 221, 249, 114, 77, 154, 179, 95, 207, 127, 9, 154, 30,
            91, 99, 67, 160, 94, 33, 239, 178, 32, 173, 245, 25, 91, 153, 189, 34, 216, 16, 100,
            160, 145, 150, 208, 85, 135, 237, 13, 225, 234, 144, 137, 224, 217, 187, 77, 10, 51,
            240, 45, 72, 9, 184, 164, 195, 153, 55, 66, 98, 110, 208, 204, 45, 204, 14, 46, 195,
            119, 25, 83, 120, 223, 17, 167, 79, 75, 68, 182, 105, 97, 176, 15, 153, 95, 170, 16,
            33, 172, 134, 114, 73, 69, 5, 49, 78, 133, 250, 44, 136, 75, 179, 33, 213, 48, 77, 236,
            16, 148, 221, 74, 185, 209, 83, 94, 167, 180, 101, 170, 91, 129, 143, 228, 180, 251,
            185, 210, 16, 74, 26, 248, 65, 208, 73, 182, 161, 120, 59, 223, 98, 166, 58, 94, 69,
            250, 93, 75, 29, 36, 41, 211, 242, 115, 253, 65, 28, 204, 117, 167, 194, 113, 98, 180,
            54, 96, 170, 81, 125, 134, 19, 213, 2, 213, 178, 163, 108, 74, 215, 177, 52, 217, 75,
            225, 144, 220, 3, 164, 87, 156, 233, 1, 99, 218, 251, 89, 45, 165, 227, 98, 232, 143,
            165, 141, 246, 196, 230, 209, 136, 35, 75, 218, 63, 15, 94, 150, 79, 113, 245, 247, 28,
            139, 115, 136, 232, 175, 49, 228, 11, 70, 234, 131, 126, 167, 31, 234, 202, 34, 27,
            240, 195, 201, 1, 29, 98, 229, 254, 146, 87, 223, 113, 5, 218, 217, 250, 58, 115, 53,
            9, 162, 175, 42, 176, 10, 195, 48, 155, 56, 58, 246, 219, 98, 166, 41, 34, 216, 225,
            29, 28, 1, 18, 89,
        ];
        let a_proof = [
            33, 202, 204, 21, 29, 11, 142, 163, 254, 113, 245, 137, 104, 89, 101, 247, 182, 215,
            41, 42, 213, 171, 173, 142, 172, 183, 214, 187, 204, 48, 253, 153, 224, 246, 18, 246,
            72, 5, 95, 165, 27, 245, 255, 22, 229, 250, 129, 33, 8, 40, 1, 194, 131, 19, 51, 75,
            37, 179, 34, 60, 222, 13, 182, 81,
        ];
        let salt = [
            67, 81, 86, 223, 10, 171, 140, 180, 0, 188, 111, 77, 228, 110, 173, 185,
        ];
        let shared_secret = [
            39, 162, 132, 15, 245, 98, 72, 107, 190, 101, 117, 162, 228, 189, 241, 14, 132, 216,
            104, 7, 65, 72, 90, 154, 86, 129, 171, 235, 197, 55, 174, 216, 183, 170, 12, 101, 219,
            128, 62, 155, 113, 212, 250, 40, 137, 178, 199, 215, 68, 139, 218, 112, 205, 68, 52,
            66, 95, 11, 116, 251, 143, 93, 206, 89,
        ];

        let b_proof = verify_client_proof::<Sha512>(
            &b_pub,
            &a_pub,
            &a_proof,
            b"Pair-Setup",
            &salt,
            &shared_secret,
            &G_3072,
        )
        .unwrap();

        assert_eq!(
            b_proof,
            vec![
                53, 222, 231, 209, 7, 123, 202, 208, 135, 119, 183, 90, 79, 154, 55, 155, 63, 56,
                215, 210, 4, 20, 229, 119, 234, 168, 107, 137, 48, 172, 180, 244, 184, 142, 170,
                120, 188, 106, 94, 135, 122, 4, 211, 21, 190, 26, 121, 180, 13, 192, 173, 246, 172,
                223, 161, 192, 52, 251, 187, 66, 52, 170, 18, 85
            ]
        );
    }

    #[test]
    fn test_client_proof() {
        let b_proof =
            verify_client_proof::<Sha512>(B, A, M1, b"Pair-Setup", &s, K, &G_3072).unwrap();

        assert_eq!(b_proof, M2);
    }
}
